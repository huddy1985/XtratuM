\section{Introduction}
XM/eRTL is an embedded real-time system which comprises of XtratuM and PaRTiKle. XtratuM is a hypervisor and PaRTiKle is a new open source real-time kernel for embedded systems, especially the PaRTiKle is POSIX complied and support RTLinux/GPL applications, so the PaRTiKle is named eRTL in the XM/eRTL. XM/eRTL has the characteristics from XtratuM and PaRTiKle. 
\\
Before going on introduce XM/eRTL system, let's clear about the main concepts in XM/eRTL system again. XtratuM is a hypervisor which can run based on Linux, and PaRTiKle is another kind of POSIX threads embedded real-time system. XM/eRTL system is the combination of XtratuM and PaRTiKle or PaRTiKle is ported to XtratuM system and run as a XtratuM domain. Domain is the smallest task running on XtratuM. Linux is a domain too. But XtrautM should be based on Linux, so Linux is called root domain. PaRTiKle is real-time and in XM/eRTL system, PaRTiKle is a real-time domain. In the whole system, XtratuM runs in the lowest level which can direct hardware level, Linux and PaRTiKle are in the same level and run on XtratuM. So the programmer can write the application for XtratuM, PaRTiKle and LINUX separately. The applications running on XtratuM are domains which same as Linux and PaRTiKle. The application programmed for PaRTiKle is real-time thread. And applications running on Linux are normal process. In the released version, XM/eRTL system is consisted of XtratuM and PaRTiKle only, not including Linux.  
\\
XM/eRTL system is a nano-kernel system. Only few functions are supported by XM/eRTL kernel, interrupt management, timer management, and domain scheduler. The most system functions are done by peripheral components and domains. Linux is the root domain offering memory allocation and system booting service. Two IDC tools can be used to transfer data between domains, XM/FIFO and XM/SHM. One device driver model is built for XM/eRTL for porting and building new device driver. In the XM/eRTL, the XM/Serial device driver is the only real-time device driver implemented now. And programmers can use trace tool to trace the events triggered in the XM/eRTL kernel: XtratuM.
\\
Different from RTLinux/GPL which is dual-core system, XM/eRTL is multi-core system. The purpose of XM/eRTL is to build more stable and reliable real time system and support the application running RTLinux/GPL. RTLinux/GPL which was one of most famous real-time Linux system in the open source area is a hard realtime RTOS runs the entire Linux operating system as a fully preemptable process. Wind River Systems acquired the RTLinux copyright in 2007 and now makes a version available as Wind River Real-Time Core for Wind River Linux. In order to support the RTLinux/GPL applications, XM/eRTL is built by the RTLinux/GPL community to replace RTLinux/GPL system. One of most important characteristics of XM/eRTL is RTLinux/GPL compatible.
\\
The basic idea behind of XM/eRTL is hypervisor architecture. In the architecture, both real-time and non-real-time application can be supported. The XM/eRTL is the hard real-time and the system scheduler support runtime preemption. So the systems or domains running on XM/eRTL can inherit the real-time property from the original operating system, such as Linux and PaRTiKle. The core kernel of XM/eRTL is XtratuM, which is the real hypervisor. XtratuM focus on the interrupt management, timer management and domains scheduler which are critical components for real-time system. 
\\
In XM/eRTL, Linux with XtratuM patch boots the machine first, initializing the whole system as normal, such as devices initialization, memory initialization, interrupt and timer initialization (not for XM/eRTL), etc. So Linux installation and booting are basic operation or preparation for building XM/eRTL. When the Linux boots successfully, XtratuM can be loaded. XtratuM start taking over the machine management permissions from Linux. The process starts from interrupt takeover, then entry timer takeover, and at last jumping in XtratuM scheduling era. When the process over, the old environment is changed too much. Linux is not the whole system running on the machine, and it is not the administrator of the system any more. Linux becomes the root domain whose interrupt and timer management permission have been take over by XtratuM. But Linux is the main roles offering device service and memory service. Linux can be scheduler by XtratuM. When there is no any domain whose priority is higher than Linux, the CPU will be assigned to Linux. 
\\
When XtratuM takeover Linux interrupt and timer successfully, the system can be used to build Linux applications and XtratuM domains. Linux applications programming is simple as usually. XtratuM domains programming introduction can be found in the 6.1 section which shows how to build and run a new domain. And the Appendix II shows XtratuM hypercalls which can be used by domains.
\\
PaRTiKle is special embedded real-time system. It can run as a standalone operation system or as a Linux process. In XM/eRTL, PaRTiKle runs as a domain with higher priority. PaRTiKle is a POSIX THREAD compatible operating system. The application following POSIX THREAD can be ported to PaRTiKle with little or without source code modification. In order to support RTLinux/GPL applications, PaRTiKle is ported to XtratuM. And PaRTiKle and XtratuM are the two most important components in XM/eRTL system. Section 6.2 will show how to build real-time thread based on PaRTiKle.
\\
XtratuM and PaRTiKle are core components in XM/eRTL. Excepting for the basic services, some important functions are offered by them too. Those functions include IDC (Inter-Domain Communication) function, device driver model and trace function. FIFO and SHM are both IDC tools offered by XtratuM. The IDC is used to transfer data between kinds of domains. Conventional, FIFO is used for stream data and SHM is used to transfer block data. Device driver model is used to build or add new device driver for XM/eRTL. The trace tool is used to trace the triggered events. In other sections, those functions will be explained in detail.   
\\
The whole manual is divided into six sections. This is the section one which showed what is XM/eRTL roughly. 
Section 2 is installation. In the section, XM/eRTL environment building will be explained in detail. From introduction section, it is clear that the installation process should include Linux Installation, XtratuM installation and PaRTiKle installation. In order to boot XtratuM and manage the domains, some useful tools offered by XM/eRTL. The section will introduce XM/eRTL tools and explain tools usage.
\\
Section 3 is IDC tools. IDC tools are used to transfer data between domains. There are two IDC tools in XM/eRTL now, XM/FIFO and XM/SHM. XM/FIFO adopts memory mapping and lock free mechanism. The tool is fit for stream data transmission. Different from XM/FIFO, XM/SHM is fit for block data transmission. 
\\
Section 4 is Device Driver. The section includes device deriver model in XtratuM and serial device driver which is the only hardware device driver offered by XtratuM. Following XM/DEV (XtratuM DEVice Driver Model), the hardware device driver comprised of static component and dynamic component. The static component is located in Linux kernel. They are used to initiate the device, apply the source, and release source. The dynamic component is main body which will access and manage the device in run-time, and normally the dynamic component is a scheduled domain. The serial device driver is built with the XM/DEV model. 
\\
Section 5 is Trace tool. XM trace uses statically allocated shared memory to buer timestamp, address and type of events. Both hard-coded system events and user-dened events are supported. xmtrace provides adequate trace points in the XtratuM code base for critical functions like scheduling, enabling/disabling interrupts, and acquiring/ freeing spin locks. Custom events can be added and triggered by the user via a simple interface. Events are grouped into event classes. Single events and event classes can be enabled and disabled as required, which makes the Tracer very flexible.
\\
Section 6 is exercise. Beginners can learn how to write domain and thread applications in the XM/eRTL system. Domain is the scheduled unit on XtratuM and thread is for PaRTiKle system. Domains is nearer from XtratuM than the thread which above the PaRTiKle. So domains have lower kinds of latency, such as interrupt latency and timer latency. It will be complex to build a domain by hand from scratch and PaRTiKle is an appreciate choice. PaRTiKle is a specially domain which offers POSIX thread API to programmer. It is easier to write the thread for PaRTiKle. In order to resolve one problem, domain and thread may be resolution both. Having a think should be done before selection.        

